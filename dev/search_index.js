var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RecursiveTupleMath","category":"page"},{"location":"#RecursiveTupleMath","page":"Home","title":"RecursiveTupleMath","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RecursiveTupleMath.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RecursiveTupleMath]","category":"page"},{"location":"#RecursiveTupleMath.RecursiveTupleMath","page":"Home","title":"RecursiveTupleMath.RecursiveTupleMath","text":"Implements broadcasting functions that operate elementwise and recursively across Tuples, NamedTuples, SArrays, and ForwardDiff.Dual numbers.\n\nThe functions are:\n- `badd` (broadcast add)\n- `bsub` (broadcast sub)\n- `bmul` (broadcast mul)\n- `bdiv` (broadcast div)\n- `bmax` (broadcast max)\n- `bmin` (broadcast min)\n\nNote that because it is recursive, bmul(a, b) will not necessarilly do the same thing as map(*, a, b). For example, if a and b are tuples of SMatrices, bmul will multiply them elementwise, while map will multiply them as matrices. This is because bmul will call bmul on the elements of a and b, while map will call * on the elements of a and b.\n\n\n\n\n\n","category":"module"}]
}
